<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>JSON Schema Validation: A Vocabulary for Structural Validation of JSON </title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 Conventions and Terminology">
<link href="#rfc.section.3" rel="Chapter" title="3 Overview">
<link href="#rfc.section.4" rel="Chapter" title="4 Interoperability Considerations">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Validation of String Instances">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Validation of Numeric Instances">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Regular Expressions">
<link href="#rfc.section.5" rel="Chapter" title="5 Meta-Schema">
<link href="#rfc.section.6" rel="Chapter" title="6 A Vocabulary for Structural Validation">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Validation Keywords for Any Instance Type">
<link href="#rfc.section.6.1.1" rel="Chapter" title="6.1.1 type">
<link href="#rfc.section.6.1.2" rel="Chapter" title="6.1.2 enum">
<link href="#rfc.section.6.1.3" rel="Chapter" title="6.1.3 const">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Validation Keywords for Numeric Instances (number and integer)">
<link href="#rfc.section.6.2.1" rel="Chapter" title="6.2.1 multipleOf">
<link href="#rfc.section.6.2.2" rel="Chapter" title="6.2.2 maximum">
<link href="#rfc.section.6.2.3" rel="Chapter" title="6.2.3 exclusiveMaximum">
<link href="#rfc.section.6.2.4" rel="Chapter" title="6.2.4 minimum">
<link href="#rfc.section.6.2.5" rel="Chapter" title="6.2.5 exclusiveMinimum">
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Validation Keywords for Strings">
<link href="#rfc.section.6.3.1" rel="Chapter" title="6.3.1 maxLength">
<link href="#rfc.section.6.3.2" rel="Chapter" title="6.3.2 minLength">
<link href="#rfc.section.6.3.3" rel="Chapter" title="6.3.3 pattern">
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 Validation Keywords for Arrays">
<link href="#rfc.section.6.4.1" rel="Chapter" title="6.4.1 maxItems">
<link href="#rfc.section.6.4.2" rel="Chapter" title="6.4.2 minItems">
<link href="#rfc.section.6.4.3" rel="Chapter" title="6.4.3 uniqueItems">
<link href="#rfc.section.6.4.4" rel="Chapter" title="6.4.4 maxContains">
<link href="#rfc.section.6.4.5" rel="Chapter" title="6.4.5 minContains">
<link href="#rfc.section.6.5" rel="Chapter" title="6.5 Validation Keywords for Objects">
<link href="#rfc.section.6.5.1" rel="Chapter" title="6.5.1 maxProperties">
<link href="#rfc.section.6.5.2" rel="Chapter" title="6.5.2 minProperties">
<link href="#rfc.section.6.5.3" rel="Chapter" title="6.5.3 required">
<link href="#rfc.section.6.5.4" rel="Chapter" title="6.5.4 dependentRequired">
<link href="#rfc.section.7" rel="Chapter" title='7 Vocabularies for Semantic Content With "format"'>
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Foreword">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Implementation Requirements">
<link href="#rfc.section.7.2.1" rel="Chapter" title="7.2.1 Format-Annotation Vocabulary">
<link href="#rfc.section.7.2.2" rel="Chapter" title="7.2.2 Format-Assertion Vocabulary">
<link href="#rfc.section.7.2.3" rel="Chapter" title="7.2.3 Custom format attributes">
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Defined Formats">
<link href="#rfc.section.7.3.1" rel="Chapter" title="7.3.1 Dates, Times, and Duration">
<link href="#rfc.section.7.3.2" rel="Chapter" title="7.3.2 Email Addresses">
<link href="#rfc.section.7.3.3" rel="Chapter" title="7.3.3 Hostnames">
<link href="#rfc.section.7.3.4" rel="Chapter" title="7.3.4 IP Addresses">
<link href="#rfc.section.7.3.5" rel="Chapter" title="7.3.5 Resource Identifiers">
<link href="#rfc.section.7.3.6" rel="Chapter" title="7.3.6 uri-template">
<link href="#rfc.section.7.3.7" rel="Chapter" title="7.3.7 JSON Pointers">
<link href="#rfc.section.7.3.8" rel="Chapter" title="7.3.8 regex">
<link href="#rfc.section.8" rel="Chapter" title="8 A Vocabulary for the Contents of String-Encoded Data">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Foreword">
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 Implementation Requirements">
<link href="#rfc.section.8.3" rel="Chapter" title="8.3 contentEncoding">
<link href="#rfc.section.8.4" rel="Chapter" title="8.4 contentMediaType">
<link href="#rfc.section.8.5" rel="Chapter" title="8.5 contentSchema">
<link href="#rfc.section.8.6" rel="Chapter" title="8.6 Example">
<link href="#rfc.section.9" rel="Chapter" title="9 A Vocabulary for Basic Meta-Data Annotations">
<link href="#rfc.section.9.1" rel="Chapter" title='9.1 "title" and "description"'>
<link href="#rfc.section.9.2" rel="Chapter" title='9.2 "default"'>
<link href="#rfc.section.9.3" rel="Chapter" title='9.3 "deprecated"'>
<link href="#rfc.section.9.4" rel="Chapter" title='9.4 "readOnly" and "writeOnly"'>
<link href="#rfc.section.9.5" rel="Chapter" title='9.5 "examples"'>
<link href="#rfc.section.10" rel="Chapter" title="10 Security Considerations">
<link href="#rfc.references" rel="Chapter" title="11 References">
<link href="#rfc.references.1" rel="Chapter" title="11.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="11.2 Informative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A Keywords Moved from Validation to Core">
<link href="#rfc.appendix.B" rel="Chapter" title="B Acknowledgments">
<link href="#rfc.appendix.C" rel="Chapter" title="C ChangeLog">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.30.0 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Wright, A., Ed., Andrews, H., Ed., and B. Hutton, Ed." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-bhutton-json-schema-validation-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2020-28" />
  <meta name="dct.abstract" content="JSON Schema (application/schema+json) has several purposes, one of which is JSON instance validation.  This document specifies a vocabulary for JSON Schema to describe the meaning of JSON documents, provide hints for user interfaces working with JSON data, and to make assertions about what a valid document must look like.  " />
  <meta name="description" content="JSON Schema (application/schema+json) has several purposes, one of which is JSON instance validation.  This document specifies a vocabulary for JSON Schema to describe the meaning of JSON documents, provide hints for user interfaces working with JSON data, and to make assertions about what a valid document must look like.  " />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Internet Engineering Task Force</td>
<td class="right">A. Wright, Ed.</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right"></td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">H. Andrews, Ed.</td>
</tr>
<tr>
<td class="left">Expires: August 1, 2021</td>
<td class="right"></td>
</tr>
<tr>
<td class="left"></td>
<td class="right">B. Hutton, Ed.</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">January 28, 2020</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">JSON Schema Validation: A Vocabulary for Structural Validation of JSON <br />
  <span class="filename">draft-bhutton-json-schema-validation-00</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>JSON Schema (application/schema+json) has several purposes, one of which is JSON instance validation.  This document specifies a vocabulary for JSON Schema to describe the meaning of JSON documents, provide hints for user interfaces working with JSON data, and to make assertions about what a valid document must look like.  </p>
<h1><a>Note to Readers</a></h1>
<p>The issues list for this draft can be found at <span>&lt;</span><a href="https://github.com/json-schema-org/json-schema-spec/issues">https://github.com/json-schema-org/json-schema-spec/issues</a><span>&gt;</span>.  </p>
<p>For additional information, see <span>&lt;</span><a href="https://json-schema.org/">https://json-schema.org/</a><span>&gt;</span>.  </p>
<p>To provide feedback, use this issue tracker, the communication methods listed on the homepage, or email the document editors.  </p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on August 1, 2021.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2020 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>2.   <a href="#rfc.section.2">Conventions and Terminology</a>
</li>
<li>3.   <a href="#rfc.section.3">Overview</a>
</li>
<li>4.   <a href="#rfc.section.4">Interoperability Considerations</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Validation of String Instances</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Validation of Numeric Instances</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">Regular Expressions</a>
</li>
</ul><li>5.   <a href="#rfc.section.5">Meta-Schema</a>
</li>
<li>6.   <a href="#rfc.section.6">A Vocabulary for Structural Validation</a>
</li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Validation Keywords for Any Instance Type</a>
</li>
<ul><li>6.1.1.   <a href="#rfc.section.6.1.1">type</a>
</li>
<li>6.1.2.   <a href="#rfc.section.6.1.2">enum</a>
</li>
<li>6.1.3.   <a href="#rfc.section.6.1.3">const</a>
</li>
</ul><li>6.2.   <a href="#rfc.section.6.2">Validation Keywords for Numeric Instances (number and integer)</a>
</li>
<ul><li>6.2.1.   <a href="#rfc.section.6.2.1">multipleOf</a>
</li>
<li>6.2.2.   <a href="#rfc.section.6.2.2">maximum</a>
</li>
<li>6.2.3.   <a href="#rfc.section.6.2.3">exclusiveMaximum</a>
</li>
<li>6.2.4.   <a href="#rfc.section.6.2.4">minimum</a>
</li>
<li>6.2.5.   <a href="#rfc.section.6.2.5">exclusiveMinimum</a>
</li>
</ul><li>6.3.   <a href="#rfc.section.6.3">Validation Keywords for Strings</a>
</li>
<ul><li>6.3.1.   <a href="#rfc.section.6.3.1">maxLength</a>
</li>
<li>6.3.2.   <a href="#rfc.section.6.3.2">minLength</a>
</li>
<li>6.3.3.   <a href="#rfc.section.6.3.3">pattern</a>
</li>
</ul><li>6.4.   <a href="#rfc.section.6.4">Validation Keywords for Arrays</a>
</li>
<ul><li>6.4.1.   <a href="#rfc.section.6.4.1">maxItems</a>
</li>
<li>6.4.2.   <a href="#rfc.section.6.4.2">minItems</a>
</li>
<li>6.4.3.   <a href="#rfc.section.6.4.3">uniqueItems</a>
</li>
<li>6.4.4.   <a href="#rfc.section.6.4.4">maxContains</a>
</li>
<li>6.4.5.   <a href="#rfc.section.6.4.5">minContains</a>
</li>
</ul><li>6.5.   <a href="#rfc.section.6.5">Validation Keywords for Objects</a>
</li>
<ul><li>6.5.1.   <a href="#rfc.section.6.5.1">maxProperties</a>
</li>
<li>6.5.2.   <a href="#rfc.section.6.5.2">minProperties</a>
</li>
<li>6.5.3.   <a href="#rfc.section.6.5.3">required</a>
</li>
<li>6.5.4.   <a href="#rfc.section.6.5.4">dependentRequired</a>
</li>
</ul></ul><li>7.   <a href="#rfc.section.7">Vocabularies for Semantic Content With "format"</a>
</li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Foreword</a>
</li>
<li>7.2.   <a href="#rfc.section.7.2">Implementation Requirements</a>
</li>
<ul><li>7.2.1.   <a href="#rfc.section.7.2.1">Format-Annotation Vocabulary</a>
</li>
<li>7.2.2.   <a href="#rfc.section.7.2.2">Format-Assertion Vocabulary</a>
</li>
<li>7.2.3.   <a href="#rfc.section.7.2.3">Custom format attributes</a>
</li>
</ul><li>7.3.   <a href="#rfc.section.7.3">Defined Formats</a>
</li>
<ul><li>7.3.1.   <a href="#rfc.section.7.3.1">Dates, Times, and Duration</a>
</li>
<li>7.3.2.   <a href="#rfc.section.7.3.2">Email Addresses</a>
</li>
<li>7.3.3.   <a href="#rfc.section.7.3.3">Hostnames</a>
</li>
<li>7.3.4.   <a href="#rfc.section.7.3.4">IP Addresses</a>
</li>
<li>7.3.5.   <a href="#rfc.section.7.3.5">Resource Identifiers</a>
</li>
<li>7.3.6.   <a href="#rfc.section.7.3.6">uri-template</a>
</li>
<li>7.3.7.   <a href="#rfc.section.7.3.7">JSON Pointers</a>
</li>
<li>7.3.8.   <a href="#rfc.section.7.3.8">regex</a>
</li>
</ul></ul><li>8.   <a href="#rfc.section.8">A Vocabulary for the Contents of String-Encoded Data</a>
</li>
<ul><li>8.1.   <a href="#rfc.section.8.1">Foreword</a>
</li>
<li>8.2.   <a href="#rfc.section.8.2">Implementation Requirements</a>
</li>
<li>8.3.   <a href="#rfc.section.8.3">contentEncoding</a>
</li>
<li>8.4.   <a href="#rfc.section.8.4">contentMediaType</a>
</li>
<li>8.5.   <a href="#rfc.section.8.5">contentSchema</a>
</li>
<li>8.6.   <a href="#rfc.section.8.6">Example</a>
</li>
</ul><li>9.   <a href="#rfc.section.9">A Vocabulary for Basic Meta-Data Annotations</a>
</li>
<ul><li>9.1.   <a href="#rfc.section.9.1">"title" and "description"</a>
</li>
<li>9.2.   <a href="#rfc.section.9.2">"default"</a>
</li>
<li>9.3.   <a href="#rfc.section.9.3">"deprecated"</a>
</li>
<li>9.4.   <a href="#rfc.section.9.4">"readOnly" and "writeOnly"</a>
</li>
<li>9.5.   <a href="#rfc.section.9.5">"examples"</a>
</li>
</ul><li>10.   <a href="#rfc.section.10">Security Considerations</a>
</li>
<li>11.   <a href="#rfc.references">References</a>
</li>
<ul><li>11.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>11.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Keywords Moved from Validation to Core</a>
</li>
<li>Appendix B.   <a href="#rfc.appendix.B">Acknowledgments</a>
</li>
<li>Appendix C.   <a href="#rfc.appendix.C">ChangeLog</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">JSON Schema can be used to require that a given JSON document (an instance) satisfies a certain number of criteria. These criteria are asserted by using keywords described in this specification. In addition, a set of keywords is also defined to assist in interactive user interface instance generation.  </p>
<p id="rfc.section.1.p.2">This specification will use the concepts, syntax, and terminology defined by the <a href="#json-schema" class="xref">JSON Schema core</a> specification.  </p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> Conventions and Terminology</h1>
<p id="rfc.section.2.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119" class="xref">RFC 2119</a>.  </p>
<p id="rfc.section.2.p.2">This specification uses the term "container instance" to refer to both array and object instances. It uses the term "children instances" to refer to array elements or object member values.  </p>
<p id="rfc.section.2.p.3">Elements in an array value are said to be unique if no two elements of this array are <a href="#json-schema" class="xref">equal</a>.  </p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> Overview</h1>
<p id="rfc.section.3.p.1">JSON Schema validation asserts constraints on the structure of instance data.  An instance location that satisfies all asserted constraints is then annotated with any keywords that contain non-assertion information, such as descriptive metadata and usage hints.  If all locations within the instance satisfy all asserted constraints, then the instance is said to be valid against the schema.  </p>
<p id="rfc.section.3.p.2">Each schema object is independently evaluated against each instance location to which it applies.  This greatly simplifies the implementation requirements for validators by ensuring that they do not need to maintain state across the document-wide validation process.  </p>
<p id="rfc.section.3.p.3">This specification defines a set of assertion keywords, as well as a small vocabulary of metadata keywords that can be used to annotate the JSON instance with useful information.  The <a href="#format" class="xref">Section 7</a> keyword is intended primarily as an annotation, but can optionally be used as an assertion.  The <a href="#content" class="xref">Section 8</a> keywords are annotations for working with documents embedded as JSON strings.  </p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> Interoperability Considerations</h1>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> Validation of String Instances</h1>
<p id="rfc.section.4.1.p.1">It should be noted that the nul character (\u0000) is valid in a JSON string. An instance to validate may contain a string value with this character, regardless of the ability of the underlying programming language to deal with such data.  </p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> Validation of Numeric Instances</h1>
<p id="rfc.section.4.2.p.1">The JSON specification allows numbers with arbitrary precision, and JSON Schema does not add any such bounds.  This means that numeric instances processed by JSON Schema can be arbitrarily large and/or have an arbitrarily long decimal part, regardless of the ability of the underlying programming language to deal with such data.  </p>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> <a href="#regexInterop" id="regexInterop">Regular Expressions</a>
</h1>
<p id="rfc.section.4.3.p.1">Keywords that use regular expressions, or constrain the instance value to be a regular expression, are subject to the interoperability considerations for regular expressions in the <a href="#json-schema" class="xref">JSON Schema Core</a> specification.  </p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#meta-schema" id="meta-schema">Meta-Schema</a>
</h1>
<p id="rfc.section.5.p.1">The current URI for the default JSON Schema dialect meta-schema is <span>&lt;</span><a href="https://json-schema.org/draft/2020-12/schema">https://json-schema.org/draft/2020-12/schema</a><span>&gt;</span>.  For schema author convenience, this meta-schema describes a dialect consisting of all vocabularies defined in this specification and the JSON Schema Core specification, as well as two former keywords which are reserved for a transitional period.  Individual vocabulary and vocabulary meta-schema URIs are given for each section below.  Certain vocabularies are optional to support, which is explained in detail in the relevant sections.  </p>
<p id="rfc.section.5.p.2">Updated vocabulary and meta-schema URIs MAY be published between specification drafts in order to correct errors.  Implementations SHOULD consider URIs dated after this specification draft and before the next to indicate the same syntax and semantics as those listed here.  </p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> A Vocabulary for Structural Validation</h1>
<p id="rfc.section.6.p.1">Validation keywords in a schema impose requirements for successful validation of an instance.  These keywords are all assertions without any annotation behavior.  </p>
<p id="rfc.section.6.p.2">Meta-schemas that do not use "$vocabulary" SHOULD be considered to require this vocabulary as if its URI were present with a value of true.  </p>
<p id="rfc.section.6.p.3">The current URI for this vocabulary, known as the Validation vocabulary, is: &lt;https://json-schema.org/draft/2020-12/vocab/validation&gt;.  </p>
<p id="rfc.section.6.p.4">The current URI for the corresponding meta-schema is: <span>&lt;</span><a href="https://json-schema.org/draft/2020-12/meta/validation">https://json-schema.org/draft/2020-12/meta/validation</a><span>&gt;</span>.  </p>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> <a href="#general" id="general">Validation Keywords for Any Instance Type</a>
</h1>
<h1 id="rfc.section.6.1.1">
<a href="#rfc.section.6.1.1">6.1.1.</a> type</h1>
<p id="rfc.section.6.1.1.p.1">The value of this keyword MUST be either a string or an array. If it is an array, elements of the array MUST be strings and MUST be unique.  </p>
<p id="rfc.section.6.1.1.p.2">String values MUST be one of the six primitive types ("null", "boolean", "object", "array", "number", or "string"), or "integer" which matches any number with a zero fractional part.  </p>
<p id="rfc.section.6.1.1.p.3">An instance validates if and only if the instance is in any of the sets listed for this keyword.  </p>
<h1 id="rfc.section.6.1.2">
<a href="#rfc.section.6.1.2">6.1.2.</a> <a href="#enum" id="enum">enum</a>
</h1>
<p id="rfc.section.6.1.2.p.1">The value of this keyword MUST be an array. This array SHOULD have at least one element. Elements in the array SHOULD be unique.  </p>
<p id="rfc.section.6.1.2.p.2">An instance validates successfully against this keyword if its value is equal to one of the elements in this keyword's array value.  </p>
<p id="rfc.section.6.1.2.p.3">Elements in the array might be of any type, including null.  </p>
<h1 id="rfc.section.6.1.3">
<a href="#rfc.section.6.1.3">6.1.3.</a> const</h1>
<p id="rfc.section.6.1.3.p.1">The value of this keyword MAY be of any type, including null.  </p>
<p id="rfc.section.6.1.3.p.2">Use of this keyword is functionally equivalent to an <a href="#enum" class="xref">"enum"</a> with a single value.  </p>
<p id="rfc.section.6.1.3.p.3">An instance validates successfully against this keyword if its value is equal to the value of the keyword.  </p>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> <a href="#numeric" id="numeric">Validation Keywords for Numeric Instances (number and integer)</a>
</h1>
<h1 id="rfc.section.6.2.1">
<a href="#rfc.section.6.2.1">6.2.1.</a> multipleOf</h1>
<p id="rfc.section.6.2.1.p.1">The value of "multipleOf" MUST be a number, strictly greater than 0.  </p>
<p id="rfc.section.6.2.1.p.2">A numeric instance is valid only if division by this keyword's value results in an integer.  </p>
<h1 id="rfc.section.6.2.2">
<a href="#rfc.section.6.2.2">6.2.2.</a> maximum</h1>
<p id="rfc.section.6.2.2.p.1">The value of "maximum" MUST be a number, representing an inclusive upper limit for a numeric instance.  </p>
<p id="rfc.section.6.2.2.p.2">If the instance is a number, then this keyword validates only if the instance is less than or exactly equal to "maximum".  </p>
<h1 id="rfc.section.6.2.3">
<a href="#rfc.section.6.2.3">6.2.3.</a> exclusiveMaximum</h1>
<p id="rfc.section.6.2.3.p.1">The value of "exclusiveMaximum" MUST be a number, representing an exclusive upper limit for a numeric instance.  </p>
<p id="rfc.section.6.2.3.p.2">If the instance is a number, then the instance is valid only if it has a value strictly less than (not equal to) "exclusiveMaximum".  </p>
<h1 id="rfc.section.6.2.4">
<a href="#rfc.section.6.2.4">6.2.4.</a> minimum</h1>
<p id="rfc.section.6.2.4.p.1">The value of "minimum" MUST be a number, representing an inclusive lower limit for a numeric instance.  </p>
<p id="rfc.section.6.2.4.p.2">If the instance is a number, then this keyword validates only if the instance is greater than or exactly equal to "minimum".  </p>
<h1 id="rfc.section.6.2.5">
<a href="#rfc.section.6.2.5">6.2.5.</a> exclusiveMinimum</h1>
<p id="rfc.section.6.2.5.p.1">The value of "exclusiveMinimum" MUST be a number, representing an exclusive lower limit for a numeric instance.  </p>
<p id="rfc.section.6.2.5.p.2">If the instance is a number, then the instance is valid only if it has a value strictly greater than (not equal to) "exclusiveMinimum".  </p>
<h1 id="rfc.section.6.3">
<a href="#rfc.section.6.3">6.3.</a> <a href="#string" id="string">Validation Keywords for Strings</a>
</h1>
<h1 id="rfc.section.6.3.1">
<a href="#rfc.section.6.3.1">6.3.1.</a> maxLength</h1>
<p id="rfc.section.6.3.1.p.1">The value of this keyword MUST be a non-negative integer.</p>
<p id="rfc.section.6.3.1.p.2">A string instance is valid against this keyword if its length is less than, or equal to, the value of this keyword.  </p>
<p id="rfc.section.6.3.1.p.3">The length of a string instance is defined as the number of its characters as defined by <a href="#RFC8259" class="xref">RFC 8259</a>.  </p>
<h1 id="rfc.section.6.3.2">
<a href="#rfc.section.6.3.2">6.3.2.</a> minLength</h1>
<p id="rfc.section.6.3.2.p.1">The value of this keyword MUST be a non-negative integer.  </p>
<p id="rfc.section.6.3.2.p.2">A string instance is valid against this keyword if its length is greater than, or equal to, the value of this keyword.  </p>
<p id="rfc.section.6.3.2.p.3">The length of a string instance is defined as the number of its characters as defined by <a href="#RFC8259" class="xref">RFC 8259</a>.  </p>
<p id="rfc.section.6.3.2.p.4">Omitting this keyword has the same behavior as a value of 0.  </p>
<h1 id="rfc.section.6.3.3">
<a href="#rfc.section.6.3.3">6.3.3.</a> <a href="#pattern" id="pattern">pattern</a>
</h1>
<p id="rfc.section.6.3.3.p.1">The value of this keyword MUST be a string. This string SHOULD be a valid regular expression, according to the ECMA-262 regular expression dialect.  </p>
<p id="rfc.section.6.3.3.p.2">A string instance is considered valid if the regular expression matches the instance successfully. Recall: regular expressions are not implicitly anchored.  </p>
<h1 id="rfc.section.6.4">
<a href="#rfc.section.6.4">6.4.</a> Validation Keywords for Arrays</h1>
<h1 id="rfc.section.6.4.1">
<a href="#rfc.section.6.4.1">6.4.1.</a> maxItems</h1>
<p id="rfc.section.6.4.1.p.1">The value of this keyword MUST be a non-negative integer.  </p>
<p id="rfc.section.6.4.1.p.2">An array instance is valid against "maxItems" if its size is less than, or equal to, the value of this keyword.  </p>
<h1 id="rfc.section.6.4.2">
<a href="#rfc.section.6.4.2">6.4.2.</a> minItems</h1>
<p id="rfc.section.6.4.2.p.1">The value of this keyword MUST be a non-negative integer.  </p>
<p id="rfc.section.6.4.2.p.2">An array instance is valid against "minItems" if its size is greater than, or equal to, the value of this keyword.  </p>
<p id="rfc.section.6.4.2.p.3">Omitting this keyword has the same behavior as a value of 0.  </p>
<h1 id="rfc.section.6.4.3">
<a href="#rfc.section.6.4.3">6.4.3.</a> uniqueItems</h1>
<p id="rfc.section.6.4.3.p.1">The value of this keyword MUST be a boolean.  </p>
<p id="rfc.section.6.4.3.p.2">If this keyword has boolean value false, the instance validates successfully. If it has boolean value true, the instance validates successfully if all of its elements are unique.  </p>
<p id="rfc.section.6.4.3.p.3">Omitting this keyword has the same behavior as a value of false.  </p>
<h1 id="rfc.section.6.4.4">
<a href="#rfc.section.6.4.4">6.4.4.</a> maxContains</h1>
<p id="rfc.section.6.4.4.p.1">The value of this keyword MUST be a non-negative integer.  </p>
<p id="rfc.section.6.4.4.p.2">If "contains" is not present within the same schema object, then this keyword has no effect.  </p>
<p id="rfc.section.6.4.4.p.3">An instance array is valid against "maxContains" in two ways, depending on the form of the annotation result of an adjacent <a href="#json-schema" class="xref">"contains"</a> keyword. The first way is if the annotation result is an array and the length of that array is less than or equal to the "maxContains" value. The second way is if the annotation result is a boolean "true" and the instance array length is less than or equal to the "maxContains" value.  </p>
<h1 id="rfc.section.6.4.5">
<a href="#rfc.section.6.4.5">6.4.5.</a> minContains</h1>
<p id="rfc.section.6.4.5.p.1">The value of this keyword MUST be a non-negative integer.  </p>
<p id="rfc.section.6.4.5.p.2">If "contains" is not present within the same schema object, then this keyword has no effect.  </p>
<p id="rfc.section.6.4.5.p.3">An instance array is valid against "minContains" in two ways, depending on the form of the annotation result of an adjacent <a href="#json-schema" class="xref">"contains"</a> keyword. The first way is if the annotation result is an array and the length of that array is greater than or equal to the "minContains" value. The second way is if the annotation result is a boolean "true" and the instance array length is greater than or equal to the "minContains" value.  </p>
<p id="rfc.section.6.4.5.p.4">A value of 0 is allowed, but is only useful for setting a range of occurrences from 0 to the value of "maxContains".  A value of 0 with no "maxContains" causes "contains" to always pass validation.  </p>
<p id="rfc.section.6.4.5.p.5">Omitting this keyword has the same behavior as a value of 1.  </p>
<h1 id="rfc.section.6.5">
<a href="#rfc.section.6.5">6.5.</a> Validation Keywords for Objects</h1>
<h1 id="rfc.section.6.5.1">
<a href="#rfc.section.6.5.1">6.5.1.</a> maxProperties</h1>
<p id="rfc.section.6.5.1.p.1">The value of this keyword MUST be a non-negative integer.  </p>
<p id="rfc.section.6.5.1.p.2">An object instance is valid against "maxProperties" if its number of properties is less than, or equal to, the value of this keyword.  </p>
<h1 id="rfc.section.6.5.2">
<a href="#rfc.section.6.5.2">6.5.2.</a> minProperties</h1>
<p id="rfc.section.6.5.2.p.1">The value of this keyword MUST be a non-negative integer.  </p>
<p id="rfc.section.6.5.2.p.2">An object instance is valid against "minProperties" if its number of properties is greater than, or equal to, the value of this keyword.  </p>
<p id="rfc.section.6.5.2.p.3">Omitting this keyword has the same behavior as a value of 0.  </p>
<h1 id="rfc.section.6.5.3">
<a href="#rfc.section.6.5.3">6.5.3.</a> required</h1>
<p id="rfc.section.6.5.3.p.1">The value of this keyword MUST be an array.  Elements of this array, if any, MUST be strings, and MUST be unique.  </p>
<p id="rfc.section.6.5.3.p.2">An object instance is valid against this keyword if every item in the array is the name of a property in the instance.  </p>
<p id="rfc.section.6.5.3.p.3">Omitting this keyword has the same behavior as an empty array.  </p>
<h1 id="rfc.section.6.5.4">
<a href="#rfc.section.6.5.4">6.5.4.</a> dependentRequired</h1>
<p id="rfc.section.6.5.4.p.1">The value of this keyword MUST be an object.  Properties in this object, if any, MUST be arrays.  Elements in each array, if any, MUST be strings, and MUST be unique.  </p>
<p id="rfc.section.6.5.4.p.2">This keyword specifies properties that are required if a specific other property is present.  Their requirement is dependent on the presence of the other property.  </p>
<p id="rfc.section.6.5.4.p.3">Validation succeeds if, for each name that appears in both the instance and as a name within this keyword's value, every item in the corresponding array is also the name of a property in the instance.  </p>
<p id="rfc.section.6.5.4.p.4">Omitting this keyword has the same behavior as an empty object.  </p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#format" id="format">Vocabularies for Semantic Content With "format"</a>
</h1>
<h1 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> Foreword</h1>
<p id="rfc.section.7.1.p.1">Structural validation alone may be insufficient to allow an application to correctly utilize certain values. The "format" annotation keyword is defined to allow schema authors to convey semantic information for a fixed subset of values which are accurately described by authoritative resources, be they RFCs or other external specifications.  </p>
<p id="rfc.section.7.1.p.2">The value of this keyword is called a format attribute. It MUST be a string. A format attribute can generally only validate a given set of instance types. If the type of the instance to validate is not in this set, validation for this format attribute and instance SHOULD succeed.  All format attributes defined in this section apply to strings, but a format attribute can be specified to apply to any instance types defined in the data model defined in the <a href="#json-schema" class="xref">core JSON Schema.</a> <a id="CREF1" class="info">[CREF1]<span class="info">Note that the "type" keyword in this specification defines an "integer" type which is not part of the data model. Therefore a format attribute can be limited to numbers, but not specifically to integers. However, a numeric format can be used alongside the "type" keyword with a value of "integer", or could be explicitly defined to always pass if the number is not an integer, which produces essentially the same behavior as only applying to integers.  </span></a> </p>
<p id="rfc.section.7.1.p.3">The current URI for this vocabulary, known as the Format-Annotation vocabulary, is: &lt;https://json-schema.org/draft/2020-12/vocab/format-annotation&gt;. The current URI for the corresponding meta-schema is: <span>&lt;</span><a href="https://json-schema.org/draft/2020-12/meta/format-annotation">https://json-schema.org/draft/2020-12/meta/format-annotation</a><span>&gt;</span>.  Implementing support for this vocabulary is REQUIRED.  </p>
<p id="rfc.section.7.1.p.4">In addition to the Format-Annotation vocabulary, a secondary vocabulary is available for custom meta-schemas that defines "format" as an assertion. The URI for the Format-Assertion vocabulary, is: &lt;https://json-schema.org/draft/2020-12/vocab/format-assertion&gt;. The current URI for the corresponding meta-schema is: <span>&lt;</span><a href="https://json-schema.org/draft/2020-12/meta/format-assertion">https://json-schema.org/draft/2020-12/meta/format-assertion</a><span>&gt;</span>.  Implementing support for the Format-Assertion vocabulary is OPTIONAL.  </p>
<p id="rfc.section.7.1.p.5">Specifying both the Format-Annotation and the Format-Assertion vocabularies is functionally equivalent to specifying only the Format-Assertion vocabulary since its requirements are a superset of the Format-Annotation vocabulary.  </p>
<h1 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> Implementation Requirements</h1>
<p id="rfc.section.7.2.p.1">The "format" keyword functions as defined by the vocabulary which is referenced.  </p>
<h1 id="rfc.section.7.2.1">
<a href="#rfc.section.7.2.1">7.2.1.</a> Format-Annotation Vocabulary</h1>
<p id="rfc.section.7.2.1.p.1">The value of format MUST be collected as an annotation, if the implementation supports annotation collection. This enables application-level validation when schema validation is unavailable or inadequate.  </p>
<p id="rfc.section.7.2.1.p.2">Implementations MAY still treat "format" as an assertion in addition to an annotation and attempt to validate the value's conformance to the specified semantics. The implementation MUST provide options to enable and disable such evaluation and MUST be disabled by default. Implementations SHOULD document their level of support for such validation.  <a id="CREF2" class="info">[CREF2]<span class="info">Specifying the Format-Annotation vocabulary and enabling validation in an implementation should not be viewed as being equivalent to specifying the Format-Assertion vocabulary since implementations are not required to provide full validation support when the Format-Assertion vocabulary is not specified.  </span></a> </p>
<p id="rfc.section.7.2.1.p.3">When the implementation is configured for assertion behavior, it: <a id="CREF3" class="info">[CREF3]<span class="info">This matches the current reality of implementations, which provide widely varying levels of validation, including no validation at all, for some or all format attributes.  It is also designed to encourage relying only on the annotation behavior and performing semantic validation in the application, which is the recommended best practice.  </span></a> </p>

<ul class="empty">
<li>SHOULD provide an implementation-specific best effort validation for each format attribute defined below; </li>
<li>MAY choose to implement validation of any or all format attributes as a no-op by always producing a validation result of true; </li>
</ul>

<p> </p>
<h1 id="rfc.section.7.2.2">
<a href="#rfc.section.7.2.2">7.2.2.</a> Format-Assertion Vocabulary</h1>
<p id="rfc.section.7.2.2.p.1">When the Format-Assertion vocabulary is declared with a value of true, implementations MUST provide full validation support for all of the formats defined by this specificaion. Implementations that cannot provide full validation support MUST refuse to process the schema.  </p>
<p id="rfc.section.7.2.2.p.2">An implementation that supports the Format-Assertion vocabulary: <a id="CREF4" class="info">[CREF4]<span class="info">The expectation is that for simple formats such as date-time, syntactic validation will be thorough.  For a complex format such as email addresses, which are the amalgamation of various standards and numerous adjustments over time, with obscure and/or obsolete rules that may or may not be restricted by other applications making use of the value, a minimal validation is sufficient.  For example, an instance string that does not contain an "@" is clearly not a valid email address, and an "email" or "hostname" containing characters outside of 7-bit ASCII is likewise clearly invalid.  </span></a> </p>

<ul class="empty">
<li>MUST still collect "format" as an annotation if the implementation supports annotation collection; </li>
<li>MUST evaluate "format" as an assertion; </li>
<li>MUST implement syntactic validation for all format attributes defined in this specification, and for any additional format attributes that it recognizes, such that there exist possible instance values of the correct type that will fail validation.  </li>
</ul>

<p> The requirement for minimal validation of format attributes is intentionally vague and permissive, due to the complexity involved in many of the attributes.  Note in particular that the requirement is limited to syntactic checking; it is not to be expected that an implementation would send an email, attempt to connect to a URL, or otherwise check the existence of an entity identified by a format instance.  </p>
<p id="rfc.section.7.2.2.p.3">It is RECOMMENDED that implementations use a common parsing library for each format, or a well-known regular expression.  Implementations SHOULD clearly document how and to what degree each format attribute is validated.  </p>
<p id="rfc.section.7.2.2.p.4">The <a href="#meta-schema" class="xref">standard core and validation meta-schema</a> includes this vocabulary in its "$vocabulary" keyword with a value of false, since by default implementations are not required to support this keyword as an assertion.  Supporting the format vocabulary with a value of true is understood to greatly increase code size and in some cases execution time, and will not be appropriate for all implementations.  </p>
<h1 id="rfc.section.7.2.3">
<a href="#rfc.section.7.2.3">7.2.3.</a> Custom format attributes</h1>
<p id="rfc.section.7.2.3.p.1">Implementations MAY support custom format attributes. Save for agreement between parties, schema authors SHALL NOT expect a peer implementation to support such custom format attributes. An implementation MUST NOT fail to collect unknown formats as annotations.  When the Format-Assertion vocabulary is specified, implementations MUST fail upon encountering unknown formats.  </p>
<p id="rfc.section.7.2.3.p.2">Vocabularies do not support specifically declaring different value sets for keywords.  Due to this limitation, and the historically uneven implementation of this keyword, it is RECOMMENDED to define additional keywords in a custom vocabulary rather than additional format attributes if interoperability is desired.  </p>
<h1 id="rfc.section.7.3">
<a href="#rfc.section.7.3">7.3.</a> Defined Formats</h1>
<h1 id="rfc.section.7.3.1">
<a href="#rfc.section.7.3.1">7.3.1.</a> Dates, Times, and Duration</h1>
<p id="rfc.section.7.3.1.p.1">These attributes apply to string instances.  </p>
<p id="rfc.section.7.3.1.p.2">Date and time format names are derived from <a href="#RFC3339" class="xref">RFC 3339, section 5.6</a>.  The duration format is from the ISO 8601 ABNF as given in Appendix A of RFC 3339.  </p>
<p id="rfc.section.7.3.1.p.3">Implementations supporting formats SHOULD implement support for the following attributes: </p>

<dl>
<dt>date-time:</dt>
<dd style="margin-left: 8">A string instance is valid against this attribute if it is a valid representation according to the "date-time" production.  </dd>
<dt>date:</dt>
<dd style="margin-left: 8">A string instance is valid against this attribute if it is a valid representation according to the "full-date" production.  </dd>
<dt>time:</dt>
<dd style="margin-left: 8">A string instance is valid against this attribute if it is a valid representation according to the "full-time" production.  </dd>
<dt>duration:</dt>
<dd style="margin-left: 8">A string instance is valid against this attribute if it is a valid representation according to the "duration" production.  </dd>
</dl>

<p> </p>
<p id="rfc.section.7.3.1.p.4">Implementations MAY support additional attributes using the other production names defined anywhere in that RFC.  If "full-date" or "full-time" are implemented, the corresponding short form ("date" or "time" respectively) MUST be implemented, and MUST behave identically.  Implementations SHOULD NOT define extension attributes with any name matching an RFC 3339 production unless it validates according to the rules of that production.  <a id="CREF5" class="info">[CREF5]<span class="info">There is not currently consensus on the need for supporting all RFC 3339 formats, so this approach of reserving the namespace will encourage experimentation without committing to the entire set.  Either the format implementation requirements will become more flexible in general, or these will likely either be promoted to fully specified attributes or dropped.  </span></a> </p>
<h1 id="rfc.section.7.3.2">
<a href="#rfc.section.7.3.2">7.3.2.</a> Email Addresses</h1>
<p id="rfc.section.7.3.2.p.1">These attributes apply to string instances.  </p>
<p id="rfc.section.7.3.2.p.2">A string instance is valid against these attributes if it is a valid Internet email address as follows: </p>

<dl>
<dt>email:</dt>
<dd style="margin-left: 8">As defined by the "Mailbox" ABNF rule in <a href="#RFC5321" class="xref">RFC 5321, section 4.1.2</a>.  </dd>
<dt>idn-email:</dt>
<dd style="margin-left: 8">As defined by the extended "Mailbox" ABNF rule in <a href="#RFC6531" class="xref">RFC 6531, section 3.3</a>.  </dd>
</dl>

<p> Note that all strings valid against the "email" attribute are also valid against the "idn-email" attribute.  </p>
<h1 id="rfc.section.7.3.3">
<a href="#rfc.section.7.3.3">7.3.3.</a> Hostnames</h1>
<p id="rfc.section.7.3.3.p.1">These attributes apply to string instances.  </p>
<p id="rfc.section.7.3.3.p.2">A string instance is valid against these attributes if it is a valid representation for an Internet hostname as follows: </p>

<dl>
<dt>hostname:</dt>
<dd style="margin-left: 8">As defined by <a href="#RFC1123" class="xref">RFC 1123, section 2.1</a>, including host names produced using the Punycode algorithm specified in <a href="#RFC5891" class="xref">RFC 5891, section 4.4</a>.  </dd>
<dt>idn-hostname:</dt>
<dd style="margin-left: 8">As defined by either RFC 1123 as for hostname, or an internationalized hostname as defined by <a href="#RFC5890" class="xref">RFC 5890, section 2.3.2.3</a>.  </dd>
</dl>

<p> Note that all strings valid against the "hostname" attribute are also valid against the "idn-hostname" attribute.  </p>
<h1 id="rfc.section.7.3.4">
<a href="#rfc.section.7.3.4">7.3.4.</a> IP Addresses</h1>
<p id="rfc.section.7.3.4.p.1">These attributes apply to string instances.  </p>
<p id="rfc.section.7.3.4.p.2">A string instance is valid against these attributes if it is a valid representation of an IP address as follows: </p>

<dl>
<dt>ipv4:</dt>
<dd style="margin-left: 8">An IPv4 address according to the "dotted-quad" ABNF syntax as defined in <a href="#RFC2673" class="xref">RFC 2673, section 3.2</a>.  </dd>
<dt>ipv6:</dt>
<dd style="margin-left: 8">An IPv6 address as defined in <a href="#RFC4291" class="xref">RFC 4291, section 2.2</a>.  </dd>
</dl>

<p> </p>
<h1 id="rfc.section.7.3.5">
<a href="#rfc.section.7.3.5">7.3.5.</a> Resource Identifiers</h1>
<p id="rfc.section.7.3.5.p.1">These attributes apply to string instances.  </p>
<p></p>

<dl>
<dt>uri:</dt>
<dd style="margin-left: 8">A string instance is valid against this attribute if it is a valid URI, according to <a href="#RFC3986" class="xref">[RFC3986]</a>.  </dd>
<dt>uri-reference:</dt>
<dd style="margin-left: 8">A string instance is valid against this attribute if it is a valid URI Reference (either a URI or a relative-reference), according to <a href="#RFC3986" class="xref">[RFC3986]</a>.  </dd>
<dt>iri:</dt>
<dd style="margin-left: 8">A string instance is valid against this attribute if it is a valid IRI, according to <a href="#RFC3987" class="xref">[RFC3987]</a>.  </dd>
<dt>iri-reference:</dt>
<dd style="margin-left: 8">A string instance is valid against this attribute if it is a valid IRI Reference (either an IRI or a relative-reference), according to <a href="#RFC3987" class="xref">[RFC3987]</a>.  </dd>
<dt>uuid:</dt>
<dd style="margin-left: 8">A string instance is valid against this attribute if it is a valid string representation of a UUID, according to <a href="#RFC4122" class="xref">[RFC4122]</a>.  </dd>
</dl>

<p> </p>
<p id="rfc.section.7.3.5.p.3">Note that all valid URIs are valid IRIs, and all valid URI References are also valid IRI References.  </p>
<p id="rfc.section.7.3.5.p.4">Note also that the "uuid" format is for plain UUIDs, not UUIDs in URNs.  An example is "f81d4fae-7dec-11d0-a765-00a0c91e6bf6".  For UUIDs as URNs, use the "uri" format, with a "pattern" regular expression of "^urn:uuid:" to indicate the URI scheme and URN namespace.  </p>
<h1 id="rfc.section.7.3.6">
<a href="#rfc.section.7.3.6">7.3.6.</a> uri-template</h1>
<p id="rfc.section.7.3.6.p.1">This attribute applies to string instances.  </p>
<p id="rfc.section.7.3.6.p.2">A string instance is valid against this attribute if it is a valid URI Template (of any level), according to <a href="#RFC6570" class="xref">[RFC6570]</a>.  </p>
<p id="rfc.section.7.3.6.p.3">Note that URI Templates may be used for IRIs; there is no separate IRI Template specification.  </p>
<h1 id="rfc.section.7.3.7">
<a href="#rfc.section.7.3.7">7.3.7.</a> JSON Pointers</h1>
<p id="rfc.section.7.3.7.p.1">These attributes apply to string instances.  </p>
<p></p>

<dl>
<dt>json-pointer:</dt>
<dd style="margin-left: 8">A string instance is valid against this attribute if it is a valid JSON string representation of a JSON Pointer, according to <a href="#RFC6901" class="xref">RFC 6901, section 5</a>.  </dd>
<dt>relative-json-pointer:</dt>
<dd style="margin-left: 8">A string instance is valid against this attribute if it is a valid <a href="#relative-json-pointer" class="xref">Relative JSON Pointer</a>.  </dd>
</dl>

<p> To allow for both absolute and relative JSON Pointers, use "anyOf" or "oneOf" to indicate support for either format.  </p>
<h1 id="rfc.section.7.3.8">
<a href="#rfc.section.7.3.8">7.3.8.</a> regex</h1>
<p id="rfc.section.7.3.8.p.1">This attribute applies to string instances.  </p>
<p id="rfc.section.7.3.8.p.2">A regular expression, which SHOULD be valid according to the <a href="#ecma262" class="xref">ECMA-262</a> regular expression dialect.  </p>
<p id="rfc.section.7.3.8.p.3">Implementations that validate formats MUST accept at least the subset of ECMA-262 defined in the <a href="#regexInterop" class="xref">Regular Expressions</a> section of this specification, and SHOULD accept all valid ECMA-262 expressions.  </p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#content" id="content">A Vocabulary for the Contents of String-Encoded Data</a>
</h1>
<h1 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> Foreword</h1>
<p id="rfc.section.8.1.p.1">Annotations defined in this section indicate that an instance contains non-JSON data encoded in a JSON string.  </p>
<p id="rfc.section.8.1.p.2">These properties provide additional information required to interpret JSON data as rich multimedia documents.  They describe the type of content, how it is encoded, and/or how it may be validated.  They do not function as validation assertions; a malformed string-encoded document MUST NOT cause the containing instance to be considered invalid.  </p>
<p id="rfc.section.8.1.p.3">Meta-schemas that do not use "$vocabulary" SHOULD be considered to require this vocabulary as if its URI were present with a value of true.  </p>
<p id="rfc.section.8.1.p.4">The current URI for this vocabulary, known as the Content vocabulary, is: &lt;https://json-schema.org/draft/2020-12/vocab/content&gt;.  </p>
<p id="rfc.section.8.1.p.5">The current URI for the corresponding meta-schema is: <span>&lt;</span><a href="https://json-schema.org/draft/2020-12/meta/content">https://json-schema.org/draft/2020-12/meta/content</a><span>&gt;</span>.  </p>
<h1 id="rfc.section.8.2">
<a href="#rfc.section.8.2">8.2.</a> Implementation Requirements</h1>
<p id="rfc.section.8.2.p.1">Due to security and performance concerns, as well as the open-ended nature of possible content types, implementations MUST NOT automatically decode, parse, and/or validate the string contents by default.  This additionally supports the use case of embedded documents intended for processing by a different consumer than that which processed the containing document.  </p>
<p id="rfc.section.8.2.p.2">All keywords in this section apply only to strings, and have no effect on other data types.  </p>
<p id="rfc.section.8.2.p.3">Implementations MAY offer the ability to decode, parse, and/or validate the string contents automatically.  However, it MUST NOT perform these operations by default, and MUST provide the validation result of each string-encoded document separately from the enclosing document.  This process SHOULD be equivalent to fully evaluating the instance against the original schema, followed by using the annotations to decode, parse, and/or validate each string-encoded document.  <a id="CREF6" class="info">[CREF6]<span class="info">For now, the exact mechanism of performing and returning parsed data and/or validation results from such an automatic decoding, parsing, and validating feature is left unspecified.  Should such a feature prove popular, it may be specified more thoroughly in a future draft.  </span></a> </p>
<p id="rfc.section.8.2.p.4">See also the <a href="#security" class="xref">Security Considerations</a> sections for possible vulnerabilities introduced by automatically processing the instance string according to these keywords.  </p>
<h1 id="rfc.section.8.3">
<a href="#rfc.section.8.3">8.3.</a> contentEncoding</h1>
<p id="rfc.section.8.3.p.1">If the instance value is a string, this property defines that the string SHOULD be interpreted as binary data and decoded using the encoding named by this property.  </p>
<p id="rfc.section.8.3.p.2">Possible values indicating base 16, 32, and 64 encodings with several variations are listed in <a href="#RFC4648" class="xref">RFC 4648</a>.  Additionally, sections 6.7 and 6.8 of <a href="#RFC2045" class="xref">RFC 2045</a> provide encodings used in MIME.  As "base64" is defined in both RFCs, the definition from RFC 4648 SHOULD be assumed unless the string is specifically intended for use in a MIME context.  Note that all of these encodings result in strings consisting only of 7-bit ASCII characters.  Therefore, this keyword has no meaning for strings containing characters outside of that range.  </p>
<p id="rfc.section.8.3.p.3">If this keyword is absent, but "contentMediaType" is present, this indicates that the encoding is the identity encoding, meaning that no transformation was needed in order to represent the content in a UTF-8 string.  </p>
<p id="rfc.section.8.3.p.4">The value of this property MUST be a string.  </p>
<h1 id="rfc.section.8.4">
<a href="#rfc.section.8.4">8.4.</a> contentMediaType</h1>
<p id="rfc.section.8.4.p.1">If the instance is a string, this property indicates the media type of the contents of the string.  If "contentEncoding" is present, this property describes the decoded string.  </p>
<p id="rfc.section.8.4.p.2">The value of this property MUST be a string, which MUST be a media type, as defined by <a href="#RFC2046" class="xref">RFC 2046</a>.  </p>
<h1 id="rfc.section.8.5">
<a href="#rfc.section.8.5">8.5.</a> contentSchema</h1>
<p id="rfc.section.8.5.p.1">If the instance is a string, and if "contentMediaType" is present, this property contains a schema which describes the structure of the string.  </p>
<p id="rfc.section.8.5.p.2">This keyword MAY be used with any media type that can be mapped into JSON Schema's data model.  </p>
<p id="rfc.section.8.5.p.3">The value of this property MUST be a valid JSON schema. It SHOULD be ignored if "contentMediaType" is not present.  </p>
<h1 id="rfc.section.8.6">
<a href="#rfc.section.8.6">8.6.</a> Example</h1>
<p>Here is an example schema, illustrating the use of "contentEncoding" and "contentMediaType": </p>
<pre>

{
    "type": "string",
    "contentEncoding": "base64",
    "contentMediaType": "image/png"
}

                    </pre>
<p>Instances described by this schema are expected to be strings, and their values should be interpretable as base64-encoded PNG images.  </p>
<p>Another example: </p>
<pre>

{
    "type": "string",
    "contentMediaType": "text/html"
}

                    </pre>
<p>Instances described by this schema are expected to be strings containing HTML, using whatever character set the JSON string was decoded into.  Per section 8.1 of <a href="#RFC8259" class="xref">RFC 8259</a>, outside of an entirely closed system, this MUST be UTF-8.  </p>
<p>This example describes a JWT that is MACed using the HMAC SHA-256 algorithm, and requires the "iss" and "exp" fields in its claim set.  </p>
<pre>

{
    "type": "string",
    "contentMediaType": "application/jwt",
    "contentSchema": {
        "type": "array",
        "minItems": 2,
        "prefixItems": [
            {
                "const": {
                    "typ": "JWT",
                    "alg": "HS256"
                }
            },
            {
                "type": "object",
                "required": ["iss", "exp"],
                "properties": {
                    "iss": {"type": "string"},
                    "exp": {"type": "integer"}
                }
            }
        ]
    }
}
                    </pre>
<p>Note that "contentEncoding" does not appear.  While the "application/jwt" media type makes use of base64url encoding, that is defined by the media type, which determines how the JWT string is decoded into a list of two JSON data structures: first the header, and then the payload.  Since the JWT media type ensures that the JWT can be represented in a JSON string, there is no need for further encoding or decoding.  </p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> A Vocabulary for Basic Meta-Data Annotations</h1>
<p id="rfc.section.9.p.1">These general-purpose annotation keywords provide commonly used information for documentation and user interface display purposes.  They are not intended to form a comprehensive set of features.  Rather, additional vocabularies can be defined for more complex annotation-based applications.  </p>
<p id="rfc.section.9.p.2">Meta-schemas that do not use "$vocabulary" SHOULD be considered to require this vocabulary as if its URI were present with a value of true.  </p>
<p id="rfc.section.9.p.3">The current URI for this vocabulary, known as the Meta-Data vocabulary, is: &lt;https://json-schema.org/draft/2020-12/vocab/meta-data&gt;.  </p>
<p id="rfc.section.9.p.4">The current URI for the corresponding meta-schema is: <span>&lt;</span><a href="https://json-schema.org/draft/2020-12/meta/meta-data">https://json-schema.org/draft/2020-12/meta/meta-data</a><span>&gt;</span>.  </p>
<h1 id="rfc.section.9.1">
<a href="#rfc.section.9.1">9.1.</a> "title" and "description"</h1>
<p id="rfc.section.9.1.p.1">The value of both of these keywords MUST be a string.  </p>
<p id="rfc.section.9.1.p.2">Both of these keywords can be used to decorate a user interface with information about the data produced by this user interface. A title will preferably be short, whereas a description will provide explanation about the purpose of the instance described by this schema.  </p>
<h1 id="rfc.section.9.2">
<a href="#rfc.section.9.2">9.2.</a> "default"</h1>
<p id="rfc.section.9.2.p.1">There are no restrictions placed on the value of this keyword.  When multiple occurrences of this keyword are applicable to a single sub-instance, implementations SHOULD remove duplicates.  </p>
<p id="rfc.section.9.2.p.2">This keyword can be used to supply a default JSON value associated with a particular schema. It is RECOMMENDED that a default value be valid against the associated schema.  </p>
<h1 id="rfc.section.9.3">
<a href="#rfc.section.9.3">9.3.</a> "deprecated"</h1>
<p id="rfc.section.9.3.p.1">The value of this keyword MUST be a boolean.  When multiple occurrences of this keyword are applicable to a single sub-instance, applications SHOULD consider the instance location to be deprecated if any occurrence specifies a true value.  </p>
<p id="rfc.section.9.3.p.2">If "deprecated" has a value of boolean true, it indicates that applications SHOULD refrain from usage of the declared property. It MAY mean the property is going to be removed in the future.  </p>
<p id="rfc.section.9.3.p.3">A root schema containing "deprecated" with a value of true indicates that the entire resource being described MAY be removed in the future.  </p>
<p id="rfc.section.9.3.p.4">The "deprecated" keyword applies to each instance location to which the schema object containing the keyword successfully applies.  This can result in scenarios where every array item or object property is deprecated even though the containing array or object is not.  </p>
<p id="rfc.section.9.3.p.5">Omitting this keyword has the same behavior as a value of false.  </p>
<h1 id="rfc.section.9.4">
<a href="#rfc.section.9.4">9.4.</a> "readOnly" and "writeOnly"</h1>
<p id="rfc.section.9.4.p.1">The value of these keywords MUST be a boolean.  When multiple occurrences of these keywords are applicable to a single sub-instance, the resulting behavior SHOULD be as for a true value if any occurrence specifies a true value, and SHOULD be as for a false value otherwise.  </p>
<p id="rfc.section.9.4.p.2">If "readOnly" has a value of boolean true, it indicates that the value of the instance is managed exclusively by the owning authority, and attempts by an application to modify the value of this property are expected to be ignored or rejected by that owning authority.  </p>
<p id="rfc.section.9.4.p.3">An instance document that is marked as "readOnly" for the entire document MAY be ignored if sent to the owning authority, or MAY result in an error, at the authority's discretion.  </p>
<p id="rfc.section.9.4.p.4">If "writeOnly" has a value of boolean true, it indicates that the value is never present when the instance is retrieved from the owning authority.  It can be present when sent to the owning authority to update or create the document (or the resource it represents), but it will not be included in any updated or newly created version of the instance.  </p>
<p id="rfc.section.9.4.p.5">An instance document that is marked as "writeOnly" for the entire document MAY be returned as a blank document of some sort, or MAY produce an error upon retrieval, or have the retrieval request ignored, at the authority's discretion.  </p>
<p id="rfc.section.9.4.p.6">For example, "readOnly" would be used to mark a database-generated serial number as read-only, while "writeOnly" would be used to mark a password input field.  </p>
<p id="rfc.section.9.4.p.7">These keywords can be used to assist in user interface instance generation.  In particular, an application MAY choose to use a widget that hides input values as they are typed for write-only fields.  </p>
<p id="rfc.section.9.4.p.8">Omitting these keywords has the same behavior as values of false.  </p>
<h1 id="rfc.section.9.5">
<a href="#rfc.section.9.5">9.5.</a> "examples"</h1>
<p id="rfc.section.9.5.p.1">The value of this keyword MUST be an array.  There are no restrictions placed on the values within the array.  When multiple occurrences of this keyword are applicable to a single sub-instance, implementations MUST provide a flat array of all values rather than an array of arrays.  </p>
<p id="rfc.section.9.5.p.2">This keyword can be used to provide sample JSON values associated with a particular schema, for the purpose of illustrating usage.  It is RECOMMENDED that these values be valid against the associated schema.  </p>
<p id="rfc.section.9.5.p.3">Implementations MAY use the value(s) of "default", if present, as an additional example.  If "examples" is absent, "default" MAY still be used in this manner.  </p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#security" id="security">Security Considerations</a>
</h1>
<p id="rfc.section.10.p.1">JSON Schema validation defines a vocabulary for JSON Schema core and concerns all the security considerations listed there.  </p>
<p id="rfc.section.10.p.2">JSON Schema validation allows the use of Regular Expressions, which have numerous different (often incompatible) implementations.  Some implementations allow the embedding of arbitrary code, which is outside the scope of JSON Schema and MUST NOT be permitted.  Regular expressions can often also be crafted to be extremely expensive to compute (with so-called "catastrophic backtracking"), resulting in a denial-of-service attack.  </p>
<p id="rfc.section.10.p.3">Implementations that support validating or otherwise evaluating instance string data based on "contentEncoding" and/or "contentMediaType" are at risk of evaluating data in an unsafe way based on misleading information.  Applications can mitigate this risk by only performing such processing when a relationship between the schema and instance is established (e.g., they share the same authority).  </p>
<p id="rfc.section.10.p.4">Processing a media type or encoding is subject to the security considerations of that media type or encoding.  For example, the security considerations of <a href="#RFC4329" class="xref">RFC 4329 Scripting Media Types</a> apply when processing JavaScript or ECMAScript encoded within a JSON string.  </p>
<h1 id="rfc.references">
<a href="#rfc.references">11.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">11.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="ecma262">[ecma262]</b></td>
<td class="top">"<a href="https://www.ecma-international.org/ecma-262/11.0">ECMA-262, 11th edition specification</a>", June 2020.</td>
</tr>
<tr>
<td class="reference"><b id="json-schema">[json-schema]</b></td>
<td class="top">
<a>Wright, A.</a>, <a>Andrews, H.</a>, <a>Hutton, B.</a> and <a>G. Dennis</a>, "<a href="https://tools.ietf.org/html/draft-bhutton-json-schema-00">JSON Schema: A Media Type for Describing JSON Documents</a>", Internet-Draft draft-bhutton-json-schema-00, December 2020.</td>
</tr>
<tr>
<td class="reference"><b id="relative-json-pointer">[relative-json-pointer]</b></td>
<td class="top">
<a>Luff, G.</a>, <a title="Cloudflare, Inc.">Andrews, H.</a> and <a>B. Hutton</a>, "<a href="https://tools.ietf.org/html/draft-handrews-relative-json-pointer-01">Relative JSON Pointers</a>", Internet-Draft draft-handrews-relative-json-pointer-01, December 2020.</td>
</tr>
<tr>
<td class="reference"><b id="RFC1123">[RFC1123]</b></td>
<td class="top">
<a>Braden, R.</a>, "<a href="https://tools.ietf.org/html/rfc1123">Requirements for Internet Hosts - Application and Support</a>", STD 3, RFC 1123, DOI 10.17487/RFC1123, October 1989.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2045">[RFC2045]</b></td>
<td class="top">
<a>Freed, N.</a> and <a>N. Borenstein</a>, "<a href="https://tools.ietf.org/html/rfc2045">Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</a>", RFC 2045, DOI 10.17487/RFC2045, November 1996.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2046">[RFC2046]</b></td>
<td class="top">
<a>Freed, N.</a> and <a>N. Borenstein</a>, "<a href="https://tools.ietf.org/html/rfc2046">Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types</a>", RFC 2046, DOI 10.17487/RFC2046, November 1996.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2673">[RFC2673]</b></td>
<td class="top">
<a>Crawford, M.</a>, "<a href="https://tools.ietf.org/html/rfc2673">Binary Labels in the Domain Name System</a>", RFC 2673, DOI 10.17487/RFC2673, August 1999.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3339">[RFC3339]</b></td>
<td class="top">
<a>Klyne, G.</a> and <a>C. Newman</a>, "<a href="https://tools.ietf.org/html/rfc3339">Date and Time on the Internet: Timestamps</a>", RFC 3339, DOI 10.17487/RFC3339, July 2002.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3986">[RFC3986]</b></td>
<td class="top">
<a>Berners-Lee, T.</a>, <a>Fielding, R.</a> and <a>L. Masinter</a>, "<a href="https://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3987">[RFC3987]</b></td>
<td class="top">
<a>Duerst, M.</a> and <a>M. Suignard</a>, "<a href="https://tools.ietf.org/html/rfc3987">Internationalized Resource Identifiers (IRIs)</a>", RFC 3987, DOI 10.17487/RFC3987, January 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4122">[RFC4122]</b></td>
<td class="top">
<a>Leach, P.</a>, <a>Mealling, M.</a> and <a>R. Salz</a>, "<a href="https://tools.ietf.org/html/rfc4122">A Universally Unique IDentifier (UUID) URN Namespace</a>", RFC 4122, DOI 10.17487/RFC4122, July 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4291">[RFC4291]</b></td>
<td class="top">
<a>Hinden, R.</a> and <a>S. Deering</a>, "<a href="https://tools.ietf.org/html/rfc4291">IP Version 6 Addressing Architecture</a>", RFC 4291, DOI 10.17487/RFC4291, February 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4648">[RFC4648]</b></td>
<td class="top">
<a>Josefsson, S.</a>, "<a href="https://tools.ietf.org/html/rfc4648">The Base16, Base32, and Base64 Data Encodings</a>", RFC 4648, DOI 10.17487/RFC4648, October 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5321">[RFC5321]</b></td>
<td class="top">
<a>Klensin, J.</a>, "<a href="https://tools.ietf.org/html/rfc5321">Simple Mail Transfer Protocol</a>", RFC 5321, DOI 10.17487/RFC5321, October 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5890">[RFC5890]</b></td>
<td class="top">
<a>Klensin, J.</a>, "<a href="https://tools.ietf.org/html/rfc5890">Internationalized Domain Names for Applications (IDNA): Definitions and Document Framework</a>", RFC 5890, DOI 10.17487/RFC5890, August 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5891">[RFC5891]</b></td>
<td class="top">
<a>Klensin, J.</a>, "<a href="https://tools.ietf.org/html/rfc5891">Internationalized Domain Names in Applications (IDNA): Protocol</a>", RFC 5891, DOI 10.17487/RFC5891, August 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6531">[RFC6531]</b></td>
<td class="top">
<a>Yao, J.</a> and <a>W. Mao</a>, "<a href="https://tools.ietf.org/html/rfc6531">SMTP Extension for Internationalized Email</a>", RFC 6531, DOI 10.17487/RFC6531, February 2012.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6570">[RFC6570]</b></td>
<td class="top">
<a>Gregorio, J.</a>, <a>Fielding, R.</a>, <a>Hadley, M.</a>, <a>Nottingham, M.</a> and <a>D. Orchard</a>, "<a href="https://tools.ietf.org/html/rfc6570">URI Template</a>", RFC 6570, DOI 10.17487/RFC6570, March 2012.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6901">[RFC6901]</b></td>
<td class="top">
<a>Bryan, P.</a>, <a>Zyp, K.</a> and <a>M. Nottingham</a>, "<a href="https://tools.ietf.org/html/rfc6901">JavaScript Object Notation (JSON) Pointer</a>", RFC 6901, DOI 10.17487/RFC6901, April 2013.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8259">[RFC8259]</b></td>
<td class="top">
<a>Bray, T.</a>, "<a href="https://tools.ietf.org/html/rfc8259">The JavaScript Object Notation (JSON) Data Interchange Format</a>", STD 90, RFC 8259, DOI 10.17487/RFC8259, December 2017.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">11.2.</a> Informative References</h1>
<table><tbody><tr>
<td class="reference"><b id="RFC4329">[RFC4329]</b></td>
<td class="top">
<a>Hoehrmann, B.</a>, "<a href="https://tools.ietf.org/html/rfc4329">Scripting Media Types</a>", RFC 4329, DOI 10.17487/RFC4329, April 2006.</td>
</tr></tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> Keywords Moved from Validation to Core</h1>
<p id="rfc.section.A.p.1">Several keywords have been moved from this document into the <a href="#json-schema" class="xref">Core Specification</a> as of this draft, in some cases with re-naming or other changes.  This affects the following former validation keywords: </p>

<dl>
<dt>"definitions"</dt>
<dd style="margin-left: 8">Renamed to "$defs" to match "$ref" and be shorter to type.  Schema vocabulary authors SHOULD NOT define a "definitions" keyword with different behavior in order to avoid invalidating schemas that still use the older name.  While "definitions" is absent in the single-vocabulary meta-schemas referenced by this document, it remains present in the default meta-schema, and implementations SHOULD assume that "$defs" and "definitions" have the same behavior when that meta-schema is used.  </dd>
<dt>"allOf", "anyOf", "oneOf", "not", "if", "then", "else",                                  "items", "additionalItems", "contains", "propertyNames",                                  "properties", "patternProperties", "additionalProperties"</dt>
<dd style="margin-left: 8">All of these keywords apply subschemas to the instance and combine their results, without asserting any conditions of their own.  Without assertion keywords, these applicators can only cause assertion failures by using the false boolean schema, or by inverting the result of the true boolean schema (or equivalent schema objects).  For this reason, they are better defined as a generic mechanism on which validation, hyper-schema, and extension vocabularies can all be based.  </dd>
<dt>"dependencies"</dt>
<dd style="margin-left: 8">This keyword had two different modes of behavior, which made it relatively challenging to implement and reason about.  The schema form has been moved to Core and renamed to "dependentSchemas", as part of the applicator vocabulary.  It is analogous to "properties", except that instead of applying its subschema to the property value, it applies it to the object containing the property.  The property name array form is retained here and renamed to "dependentRequired", as it is an assertion which is a shortcut for the conditional use of the "required" assertion keyword.  </dd>
</dl>

<p> </p>
<h1 id="rfc.appendix.B">
<a href="#rfc.appendix.B">Appendix B.</a> Acknowledgments</h1>
<p id="rfc.section.B.p.1">Thanks to Gary Court, Francis Galiegue, Kris Zyp, and Geraint Luff for their work on the initial drafts of JSON Schema.  </p>
<p id="rfc.section.B.p.2">Thanks to Jason Desrosiers, Daniel Perrett, Erik Wilde, Evgeny Poberezkin, Brad Bowman, Gowry Sankar, Donald Pipowitch, Dave Finlay, Denis Laxalde, Phil Sturgeon, Shawn Silverman, and Karen Etheridge for their submissions and patches to the document.  </p>
<h1 id="rfc.appendix.C">
<a href="#rfc.appendix.C">Appendix C.</a> ChangeLog</h1>
<p><a id="CREF7" class="info">[CREF7]<span class="info">This section to be removed before leaving Internet-Draft status.</span></a> </p>
<p></p>

<dl>
<dt>draft-bhutton-json-schema-validation-00</dt>
<dd style="margin-left: 8">
<ul>
<li>Correct email format RFC reference to 5321 instead of 5322</li>
<li>Clarified the set and meaning of "contentEncoding" values</li>
<li>Reference ECMA-262, 11th edition for regular expression support</li>
<li>Split "format" into an annotation only vocabulary and an assertion vocabulary</li>
<li>Clarify "deprecated" when applicable to arrays</li>
</ul>
<p> </p>
</dd>
<dt>draft-handrews-json-schema-validation-02</dt>
<dd style="margin-left: 8">
<ul>
<li>Grouped keywords into formal vocabularies</li>
<li>Update "format" implementation requirements in terms of vocabularies</li>
<li>By default, "format" MUST NOT be validated, although validation can be enabled</li>
<li>A vocabulary declaration can be used to require "format" validation</li>
<li>Moved "definitions" to the core spec as "$defs"</li>
<li>Moved applicator keywords to the core spec</li>
<li>Renamed the array form of "dependencies" to "dependentRequired", moved the schema form to the core spec</li>
<li>Specified all "content*" keywords as annotations, not assertions</li>
<li>Added "contentSchema" to allow applying a schema to a string-encoded document</li>
<li>Also allow RFC 4648 encodings in "contentEncoding"</li>
<li>Added "minContains" and "maxContains"</li>
<li>Update RFC reference for "hostname" and "idn-hostname"</li>
<li>Add "uuid" and "duration" formats</li>
</ul>
<p> </p>
</dd>
<dt>draft-handrews-json-schema-validation-01</dt>
<dd style="margin-left: 8">
<ul>
<li>This draft is purely a clarification with no functional changes</li>
<li>Provided the general principle behind ignoring annotations under "not" and similar cases</li>
<li>Clarified "if"/"then"/"else" validation interactions</li>
<li>Clarified "if"/"then"/"else" behavior for annotation</li>
<li>Minor formatting and cross-referencing improvements</li>
</ul>
<p> </p>
</dd>
<dt>draft-handrews-json-schema-validation-00</dt>
<dd style="margin-left: 8">
<ul>
<li>Added "if"/"then"/"else"</li>
<li>Classify keywords as assertions or annotations per the core spec</li>
<li>Warn of possibly removing "dependencies" in the future</li>
<li>Grouped validation keywords into sub-sections for readability</li>
<li>Moved "readOnly" from hyper-schema to validation meta-data</li>
<li>Added "writeOnly"</li>
<li>Added string-encoded media section, with former hyper-schema "media" keywords</li>
<li>Restored "regex" format (removal was unintentional)</li>
<li>Added "date" and "time" formats, and reserved additional RFC 3339 format names</li>
<li>I18N formats: "iri", "iri-reference", "idn-hostname", "idn-email"</li>
<li>Clarify that "json-pointer" format means string encoding, not URI fragment</li>
<li>Fixed typo that inverted the meaning of "minimum" and "exclusiveMinimum"</li>
<li>Move format syntax references into Normative References</li>
<li>JSON is a normative requirement</li>
</ul>
<p> </p>
</dd>
<dt>draft-wright-json-schema-validation-01</dt>
<dd style="margin-left: 8">
<ul>
<li>Standardized on hyphenated format names with full words ("uriref" becomes "uri-reference")</li>
<li>Add the formats "uri-template" and "json-pointer"</li>
<li>Changed "exclusiveMaximum"/"exclusiveMinimum" from boolean modifiers of "maximum"/"minimum" to independent numeric fields.</li>
<li>Split the additionalItems/items into two sections</li>
<li>Reworked properties/patternProperties/additionalProperties definition</li>
<li>Added "examples" keyword</li>
<li>Added "contains" keyword</li>
<li>Allow empty "required" and "dependencies" arrays</li>
<li>Fixed "type" reference to primitive types</li>
<li>Added "const" keyword</li>
<li>Added "propertyNames" keyword</li>
</ul>
<p> </p>
</dd>
<dt>draft-wright-json-schema-validation-00</dt>
<dd style="margin-left: 8">
<ul>
<li>Added additional security considerations</li>
<li>Removed reference to "latest version" meta-schema, use numbered version instead</li>
<li>Rephrased many keyword definitions for brevity</li>
<li>Added "uriref" format that also allows relative URI references</li>
</ul>
<p> </p>
</dd>
<dt>draft-fge-json-schema-validation-00</dt>
<dd style="margin-left: 8">
<ul>
<li>Initial draft.</li>
<li>Salvaged from draft v3.</li>
<li>Redefine the "required" keyword.</li>
<li>Remove "extends", "disallow"</li>
<li>Add "anyOf", "allOf", "oneOf", "not", "definitions", "minProperties", "maxProperties".</li>
<li>"dependencies" member values can no longer be single strings; at least one element is required in a property dependency array.</li>
<li>Rename "divisibleBy" to "multipleOf".</li>
<li>"type" arrays can no longer have schemas; remove "any" as a possible value.</li>
<li>Rework the "format" section; make support optional.</li>
<li>"format": remove attributes "phone", "style", "color"; rename "ip-address" to "ipv4"; add references for all attributes.</li>
<li>Provide algorithms to calculate schema(s) for array/object instances.</li>
<li>Add interoperability considerations.</li>
</ul>
<p> </p>
</dd>
</dl>

<p> </p>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Austin Wright</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Wright</span>
	  </span>
	</span>
	<span class="org vcardline"></span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:aaa@bzfx.net">aaa@bzfx.net</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Henry Andrews</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Andrews</span>
	  </span>
	</span>
	<span class="org vcardline"></span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:andrews_henry@yahoo.com">andrews_henry@yahoo.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Ben Hutton</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Hutton</span>
	  </span>
	</span>
	<span class="org vcardline"></span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ben@jsonschema.dev">ben@jsonschema.dev</a></span>

<span class="vcardline">URI: <a href="https://jsonschema.dev">https://jsonschema.dev</a></span>

  </address>
</div>

</body>
</html>
